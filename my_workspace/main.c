/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * 		__Implementing a Scheduler__
 * 	. Let's implement a scheduler which schedules multiple user tasks in a round-robin fashion by carrying out context switch operation.
 * 	. Round robin scheduling method is, time slices are assigned to each task in equal portions and in circular order.
 * 	. First will use systick handler to carry out the context switch operation between multiple tasks.
 * 	. Later we will change the code using pendSV handler.
 *
 *		__What is a task?__
 *	. A task is a piece of code, or a 'c' function, which does a specific job when it is allowed to run on the CPU.
 *	. A task has its own stack to create its local variables when it runs on the CPU. Also when the scheduler decides to remove
 *	  a task from the CPU, the scheduler first saves the context (state) of the task in task's private stack.
 *	. To summarize, a piece of code or a function is called a task when it is schedulable and never loses its 'state' unless it
 *	  is deleted permanently.
 *
 *	PSP (Thread Mode)			MSP (Handler Mode)
 *	T1 -> Stack-T1			Scheduler (Systick handler / PendSV handler)
 *	T2 -> Stack-T2
 *	T3 -> Stack-T3
 *	T4 -> Stack-T4
 *
 *									__Stack assessment__ (Full Descending)
 *	RAM_START																				              RAM_END
 *	<------------------------------------128KB of RAM (SRAM1+SRAM2)--------------------------------------------->
 *								| Private Stack | Private Stack | Private Stack | Private Stack | Private Stack |
 *								|   Scheduler   |	   T4	    |      T3	    |      T2	    |      T1       |
 *								|<-----1kB----->|<-----1kB----->|<-----1kB----->|<-----1kB----->|<-----1kB----->|
 *								|<-------------------------------------5kB------------------------------------->|
 *																			   /                /\               \
 *																	T2_STACK_END   T2_STACK_START T1_STACK_END	T1_STACK_START
 *																						 SP <---Stack Consumption
 *
 *			__Scheduling policy selection__
 *	. We will be using round robin preemptive scheduling
 *	. No task priority
 *	. We will use SysTick timer to generate exception for every 1ms to run the scheduler code
 *
 *			__What is scheduling__
 *	. Scheduling is an algorithm which takes the decision of preempting a running task from the CPU and takes the decision about which task
 *	  should run on the CPU next.
 *	. The decision could be based on many factors such as system load, the priority of tasks, shared resource access, or a simple round-robin method.
 *
 *			__What is context switching?__
 *	. Context switching is the procedure of switching out of the currently running task from the processor after saving the task's execution context
 *	  or state and switching in the next task's to run on the CPU by retrieving the past execution context or state of the task.
 *
 *			__What is execution context or state of a task?__
 *	. Inside a microcontroller, there is a processor or CPU (ARM cortex m3/m4).
 *	. Inside the processor, there is/are processor core(s). A processor core is a collection of various units (general purpose registers, ALU (Arithmetic
 *	  Logic Unit), Status registers, and special registers).
 *	. A processor also has its own peripherals such as NVIC (controls interrupts and exceptions from various parts of the microcontroller).
 *	  It also has Memory Protection Unit (MPU), System Control Block (SCB), Floating Point Unit (FPU), Debug Unit.
 *	. When a task is running on the processor, it makes use of general purpose registers, ALU, status registers and special registers. The collection of
 *	  general purpose registers + some special register + status registers is known as the 'state of a task'.
 *	. When the scheduler wants to switch out a task, then it should save its intermediate results of the operation which are already stored in the general
 *	  purpose registers and it should also store the status register value and some special register values into the private stack of the task.
 *	. Only after that can a scheduler switch out a task.
 *
 *
 *  		(**)Important registers to include with 'state of a task'
 *
 *	**General purpose registers: R0-R7 (Low registers) & R8-R12 (High registers)
 *
 *	**SP(R13): Stack pointers: PSP and MSP (banked versions of SP).
 *			   Another important thing, is the current value or current state of task private stack which is stored in PSP which we are using for the stack pointers
 *			   of the user tasks.
 *	**LR(R14): LR is also very important. Because it reveals some of the important information about the task handler, its stack pointer selection and other things.
 *	**PC(R15): PC is very important. Why? Because, when the scheduler was preempting or switching out a task, the PC will be holding the address of the next instruction
 *	           of that task handler. When the scheduler wants to switch in that task some time later, it should know where it should return.
 *	           Scheduler also preserves the value of PC.
 *
 *	Special registers: **PSR (Program Status Register) gives the snapshot of the current state like whether zero flag, negative flag or other flags are set or not.
 *	                   PRIMASK, FAULTMASK, BASEPRI (Exception Mask Registers)  \  [Privileged registers]  Not important
 *	                   CONTROL (CONTROL register)                              /  [Privileged registers]  Not important
 *
 *	User task is usually running with unprivileged access, so the privileged registers aren't important to save/keep track of in the 'state of a task'.
 *	The kernel or the scheduler is what alters these registers.
 *
 *			__Case of T1 switching out, T2 switching in__
 *
 *	1) Running T1
 *	2) Save the context of T1 to T1's private stack      	(PUSH)  	[Context Saving]
 *	3) Save the PSP value of T1								  			[Context Saving]
 *	4) Get current PSP value of T2							  			[Context Retrieving]
 *	5) Retrieve the context of T2 from T2's private stack 	(POP)		[Context Retrieving]
 *	6) Run T2
 *
 *			__Stacking and Unstacking during exception__
 *	1) Task 1 is running in thread mode using PSP.
 *	2) Exception happens (SysTick Exception lets say)
 *	3) Thread mode code (user task) is preempted, stacking occurs, then handler mode code runs (SysTick exception handler using MSP)
 *		a) The processor saves a stack frame when the exception happens, which is the context or state of task 1 in the stack.
 *		b) Starting at the highest memory address (Full Descending stack), the stack frame is pushed with xPSR at the highest memory address and R0 at the lowest.
 *		   PSP is now pointing at the location of R0.
 *  4) After the exception handler exits, unstacking begins (stack frame is retrieved/popped back) before returning to Task 1 (thread mode code using PSP).
 *  	a. PSP is now pointing to the location of the last stacked item, which is right before where xPSR used to be.
 *  5) We actually don't want it to return to Task 1. We want the scheduler to take it to Task 2.
 *  6) In the exception handler, you should change the PSP value (the previous PSP value belongs to Task 1's private stack). We want to change this to point to
 *     Task 2's private stack.
 *  7) We want to give the address to Task 2's Handler to PC (return address) which is also R15. Now when we exit the exception, the processor will automatically
 *     jump to Task 2's handler instead of Task 1.
 *
 *		Stack Frame only includes: R0, R1, R2, R3, R12, LR, PC, xPSR
 *		State of Task includes: R0 - R12, PSP (R13), LR (R14), PC (R15), PSR
 *
 *		So the processor already partially saves the state of the task, but it is missing some registers that should also be included.
 *		In the exception handler, the remaining registers (R4 - R11) and PSP (R13-SP) need to also be saved.
 *
 *	Exercise:
 *	Configure the systick timer to produce exception every 1ms
 *
 *	SysTick count value calculation:
 *		. Processor Clock = 16MHz
 *		. SysTick timer count clock = 16MHz
 *		. 1ms is 1kHz in frequency domain
 *		. So, to bring down SysTick timer count clock from 16MHz to 1kHz, use a divisor (reload value)
 *		. Reload value = 16000
 *
 *	For stm32-f4 mcu's, system clock is 16MHz (which is derived from HSI or high speed internal clock)
 *	The processor clock and count clock (systick timer) derive their signal from the 16MHz system clock (HSI).
 *
 *	SysTick timer count clock = 16MHz.
 *	For 1 count it takes 0.0625us
 *	0.0625us delay -> 1 count
 *	1us delay = 16 count
 *	1ms delay = 16000 count
 *
 *	4-32 System timer registers summary
 *  ---------------------------------------------
 *	0xE000E010 	SYST_CSR	RW	Privileged	SysTick Control and Status Register
 *	0xE000E014 	SYST_RVR	RW	Privileged	SysTick Reload Value Register
 *	0xE000E018 	SYST_CVR	RW	Privileged	SysTick Current Value Register
 *	0xE000E01C 	SYST_CALIB	RO	Privileged	SysTick Calibration Value Register
 *
 *
 *	Saving Context (PUSH) of T1: SF2
 *
 *	Basically when exception happens, the stacking process occurs which saves the stack frame (SF1) which includes (in order of highest to lowest memory)
 *	xPSR, PC, LR, R12, R3, R2, R1, R0 (SP-PSP was pointing here). We also have to manually push the remaining registers of the "state of a task" after SF1
 *	(we call this SF2). Then R11,R10,R9,R8,R7,R6,R5,R4 should be pushed after (again in order of highest to lowest memory location -- FD stack). The SP (PSP)
 *	is now pointing to R4.
 *
 *	Retrieving (POP) Context of T2 : SF2
 *
 *	Opposite process. First program the PSP register with the correct value of task 2's current stack pointer. Then you pop SF2. Then you exit exception handler
 *	(which unstacks SF1). Execution will resume at task 2.
 *
 *	__Task's stack area init and storing of dummy SF__
 *	. Each task can consume a maximum of 1kB of memory as a private stack.
 *	. This stack is used to hold tasks local variables and context (SF1 + SF2)
 *	. When a task is getting scheduled for the very first time, it doesn't have any context. So, the programmer should store the dummy SF1 and SF2 in Task's
 *	  stack area as part of "task initialization" sequence before launching the scheduler.
 *
 *  		__Introducing Blocking State for Tasks__
 *  . Software based delay (for loop) wastes a ton of CPU cycles and won't produce an accurate delay. Much more efficient to use a timer or blocking mechanism.
 *    The goal is to not waste any CPU cycles.
 *  . When a task has got nothing to do, it should simply call a delay function which should put the task into the blocked state from running state until
 *    the specified delay is elapsed.
 *  . We should now maintain 2 states for a task. Running and Blocked.
 *  . The scheduler should schedule only those tasks which are in Running state.
 *  . The scheduler also should unblock the blocked tasks if their blocking period is over and put them back to running state.
 *
 *			__TCB(Task Control Block) Structure__
 *	. Refer to TCB_t struct
 *
 *			__Block a task for a given number of ticks__
 *	. Let's introduce a function called "task_delay" which puts the calling task to the blocked state for a given number of ticks
 *	. E.g., task_delay(1000); if a task calls this function then task_delay function puts the task into blocked state and allows the
 *	  next task to run on the CPU.
 *	. Here, the number 1000 denotes a block period in terms of ticks, the task who calls this function is going to block for 1000 ticks
 *	  (systick exceptions), i.e., for 1000 ms since each tick happens for every 1ms.
 *	. The scheduler should check elapsed block period of each blocked task and put them back to running state if the block period is over.
 *
 *			__Idle Task__
 *	What if all the tasks are blocked? Who is going to run on the CPU?
 *	. We will use the idle task to run on the CPU if all the tasks are blocked. The idle task is like user tasks but only runs when all
 *	  user tasks are blocked, and you can put the CPU to sleep.
 *	. Idle task should always be in running state.
 *
 *			__Global tick count__
 *	. How does the scheduler decide when to put the blocked state tasks (blocked using task_delay function) back to the running state?
 *	. It has to compare the task's delay tick count with a global tick count
 *	. So, scheduler should maintain a global tick count and update it for every systick exception
 *
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"

//creating 4 tasks
void task1_handler(void); //Task 1
void task2_handler(void); //Task 2
void task3_handler(void); //Task 3
void task4_handler(void); //Task 4

void init_systick_timer(uint32_t tick_hz);
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);
void init_tasks_stack(void);
void enable_processor_faults(void);
__attribute__((naked)) void switch_sp_to_psp(void);
void save_psp_value(uint32_t stack_addr);
void update_global_tick_count(void);
uint32_t get_psp_value(void);

void task_delay(uint32_t tick_count);

uint8_t current_task = 1; //task1 is running

uint32_t g_tick_count = 0;

const uint32_t const_v_1 = 100;
const uint32_t const_v_2 = 100;
const uint8_t const_v_3 = 100;

typedef struct
{
	uint32_t psp_value;
	uint32_t block_count;
	uint8_t current_state;
	void (*task_handler)(void);
}TCB_t;

//v this is shared data/memory area. there could be a chance of race condition between thread mode code and handler mode code.
TCB_t user_tasks[MAX_TASKS]; //global array accessed by bother user_tasks and the exception handlers

void NMI_Handler(void)
{
	//here implement your real logic of handling NMI
}

//semihosting init function
extern void initialise_monitor_handles(void);

int main(void)
{
	enable_processor_faults();
	
	initialise_monitor_handles();

	init_scheduler_stack(SCHED_STACK_START);

	printf("Implementation of simple task scheduler\n");
	
	init_tasks_stack();

	led_init_all();

	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();

	for(;;);
}

//Tasks never return, they are executing always.
void idle_task(void)
{
	while(1);
}


void task1_handler(void)
{
	while(1)
	{
		printf("Task 1 is executing\n");
		led_on(LED_RED1);
		task_delay(1000);
		led_off(LED_RED1);
		task_delay(1000);
	}
}

void task2_handler(void)
{
	while(1)
	{
		printf("Task 2 is executing\n");
		led_on(LED_GREEN);
		task_delay(500);
		led_off(LED_GREEN);
		task_delay(500);
	}
}

void task3_handler(void)
{
	while(1)
	{
		printf("Task 3 is executing\n");
		led_on(LED_RED2);
		task_delay(250);
		led_off(LED_RED2);
		task_delay(250);
	}
}

void task4_handler(void)
{
	while(1)
	{
		printf("Task 4 is executing\n");
		led_on(LED_YELLOW);
		task_delay(125);
		led_off(LED_YELLOW);
		task_delay(125);
	}
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	//Calculation of reload value
	uint32_t count_value = ((SYSTICK_TIM_CLK / tick_hz) - 1);

	//Clear the value of SRVR (systick reload value register)
	*pSRVR &= ~(0x00FFFFFFFF);

	//load the value in to SRVR
	*pSRVR |= count_value;

	//do some settings
	*pSCSR |= (1 << 1); //enables SysTick exception request
	*pSCSR |= (1 << 2); //indicates the clock source (processor clock)

	//enable the systick
	*pSCSR |= (1 << 0); //enables the counter
}

//naked function has no prologue/epilogue sequences
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
	__asm volatile("MSR MSP, %0": : "r" (sched_top_of_stack) : );
	__asm volatile("BX LR");
}

//initialize dummy task stacks
void init_tasks_stack(void)
{
	user_tasks[0].current_state = TASK_READY_STATE;
	user_tasks[1].current_state = TASK_READY_STATE;
	user_tasks[2].current_state = TASK_READY_STATE;
	user_tasks[3].current_state = TASK_READY_STATE;
	user_tasks[4].current_state = TASK_READY_STATE;

	user_tasks[0].psp_value = IDLE_STACK_START;
	user_tasks[1].psp_value = T1_STACK_START;
	user_tasks[2].psp_value = T2_STACK_START;
	user_tasks[3].psp_value = T3_STACK_START;
	user_tasks[4].psp_value = T4_STACK_START;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	uint32_t *pPSP;

	for(int i = 0; i < MAX_TASKS; i++)
	{
		//place PSP starting at T[i]_TASK_START
		pPSP = (uint32_t*) user_tasks[i].psp_value;

		pPSP--; //xPSR (Start of SF1)
		*pPSP = DUMMY_XPSR; //0x01000000

		pPSP--; //PC
		*pPSP = (uint32_t) user_tasks[i].task_handler;

		pPSP--; //LR
		*pPSP = 0xFFFFFFFD; //return to thread mode, FPU off, with PSP

		//allocate memory and initialize to 0 for R0-R13
		for(int j = 0; j < 13; j++)
		{
			pPSP--;
			*pPSP = 0;
		}

		user_tasks[i].psp_value = (uint32_t)pPSP; //preserve value of PSP
	}
}

void enable_processor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= (1 << 16); //mem manage
	*pSHCSR |= (1 << 17); //bus fault
	*pSHCSR |= (1 << 18); //usage fault (if disabled, divide by zero treated as HardFault)
}

uint32_t get_psp_value(void)
{
	return user_tasks[current_task].psp_value;
}

void save_psp_value(uint32_t current_psp_value)
{
	user_tasks[current_task].psp_value = current_psp_value;
}

void update_next_task(void)
{
	int state = TASK_BLOCKED_STATE;

	for(int i = 0; i < (MAX_TASKS); i++)
	{
		current_task++;
		current_task %= MAX_TASKS;
		state = user_tasks[current_task].current_state;
		if((state == TASK_READY_STATE) && (current_task != 0)) //idle task is always ready
			break;
	}

	if(state != TASK_READY_STATE) //all tasks blocked
		current_task = 0; //idle task
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
	//1. initialize the PSP with TASK1 stack start address
	//get the value of psp of current_task (all of this uses MSP as SP)
	__asm volatile("PUSH {LR}"); //preserve LR which connects back to main() before changing its value when entering get_psp_value() function
	__asm volatile("BL get_psp_value"); //BL = branch with link, so we can return to this function while storing PSP in R0
	__asm volatile("MSR PSP, R0"); //initialize PSP
	__asm volatile("POP {LR}"); //retrieve LR that connects back to main()

	//2. change SP to PSP using CONTROL register
	__asm volatile("MOV R0, #0x02");   //SPSEL set to PSP
	__asm volatile("MSR CONTROL, R0");
	__asm volatile("BX LR"); //return to main()
}

void schedule(void)
{
	//pend the pendsv exception
	uint32_t *pICSR = (uint32_t*)0xE000ED04;
	*pICSR |= (1 << 28);
}

void task_delay(uint32_t tick_count)
{
	//disable interrupt (avoid race condition)
	INTERRUPT_DISABLE();

	if(current_task)
	{
		//global variable access shared between thread & handler mode code
		user_tasks[current_task].block_count = g_tick_count + tick_count;
		user_tasks[current_task].current_state = TASK_BLOCKED_STATE;
		schedule();
	}

	//enable interrupt (avoid race condition)
	INTERRUPT_ENABLE();
}

//scheduler to be used for context switching
__attribute__((naked)) void PendSV_Handler(void)
{
	/* Save the context of current task */
	//1. Get current running task's PSP value
	__asm volatile("MRS R0, PSP");

	//2. Using that PSP value store SF2(R4 to R11)
	//cant use PUSH because Handler mode always uses MSP
	__asm volatile("STMDB R0!, {R4-R11}"); //STMDB (store multiple registers, decrement before -- essentially PUSH operation)

	__asm volatile("PUSH {LR}");

	//3. Save the current value of PSP
	//R0 already has updated PSP value from previous line, so when BL executes it will be passed into the function save_psp_value()
	__asm volatile("BL save_psp_value");


	/* Retrieve the context of the next task */
	//1. Decide next task to run
	__asm volatile("BL update_next_task");

	//2. get its past PSP value
	__asm volatile("BL get_psp_value");

	//3. Using that PSP value retrieve SF2(R4 to R11)
	__asm volatile("LDMIA R0!, {R4-R11}"); //LDMIA (load multiple registers and increment after -- essentially POP operation)

	//4. update PSP and exit
	__asm volatile("MSR PSP, R0");

	__asm volatile("POP {LR}");

	//this step is required for naked functions as the compiler wont put prologue and epilogue sequences.
	__asm volatile("BX LR");
}

void update_global_tick_count(void)
{
	g_tick_count++;
}

void unblock_tasks(void)
{
	for(int i = 1; i < MAX_TASKS; i++) //no need to check i=0 because idle task is always running
	{
		if(user_tasks[i].current_state != TASK_READY_STATE)
		{
			if(user_tasks[i].block_count == g_tick_count)
			{
				user_tasks[i].current_state = TASK_READY_STATE;
			}
		}
	}
}

void SysTick_Handler(void)
{
	uint32_t *pICSR = (uint32_t*)0xE000ED04;

	update_global_tick_count();
	unblock_tasks();

	//pend the pendsv exception
	*pICSR |= (1 << 28);

}

//implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : HardFault\n");
	while(1);
}

void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}
