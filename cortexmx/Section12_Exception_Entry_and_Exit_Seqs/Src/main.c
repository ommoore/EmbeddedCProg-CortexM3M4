/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * 		__Exception Entry Sequence__
 *
 * 	1. Pending bit set
 * 	2. Stacking and Vector Fetch (simultaneously)
 * 		Pushing contents of the registers into stack
 * 		Fetching address of exception handler from vector table
 * 	3. Entry into the handler and Interrupt Active bit set
 * 	4. Clears the pending status (processor does it automatically)
 * 	5. Processor mode changes to Handler mode
 * 	6. Handler code executes
 * 	7. The MSP will be used for any stack operations inside the handler
 *
 *		__Exception Exit Sequence__
 *
 *	. In Cortex M3/M4 processors, the exception return mechanism is triggered using a special return address called EXC_RETURN (0xFFFFFFFD)
 *	. EXC_RETURN is generated during exception entry and is stored in the LR (LR = EXC_RETURN). Interrupt Event: Thread Mode -> Handler Mode (Stacking using PSP)
 *	. When EXC_RETURN is written to PC it triggers the exception return (PC = LR). Exception Return: Handler Mode -> Thread Mode (Unstacking using PSP)
 *
 *		__EXC_RETURN__
 *	When is it generated?
 *
 *	During an exception handler entry, the value of the return address (PC) is not stored in the LR as it is done during calling of a normal C function. Instead
 *	the exception mechanism stores the special value called EXC_RETURN in LR.
 *
 *		__Decoding EXC_RETURN value__
 *
 *	Bits  |     Descriptions     |  Values
 *	----------------------------------------
 *	31:28 | EXC_RETURN indicator |    0xF
 *  27:5  |   Reserved (all 1)   |  0xEFFFFF
 *   4    |   Stack frame type   | always 1 when FPU is not avail
 *   3    |     Return mode      | 1 = return to thread mode, 0 = return to handler mode
 *   2    |     Return stack     | 1 = return with PSP, 0 = return with MSP
 *   1    |     Reserved         |     0
 *   0    |     Reserved         |     1
 *
 *
 *                 		( Exception Return Trigger )
 *                 				 	  |
 *   ( EXC_RETURN[2] = 0 )     		<- -> 	 	( EXC_RETURN[2] = 1 )
 *             v                                  		  v
 *   ( Un-stacking using MSP )          		( Un-stacking using PSP )
 *             v                                          v
 *   ( MSP selected, CONTROL[1] = 0 ) 		    ( PSP selected, CONTROL[1] = 1 )
 *             |                                          |
 *              -----> ( Resume program execution ) <------
 *
 *   So, EXC_RETURN ==
 *       				0xFFFFFFF1 <-> Return to Handler mode, Exception return gets state from main stack, execution uses MSP after return
 *      				0xFFFFFFF9 <-> Return to Thread mode, Exception return gets state from main stack, execution uses MSP after return
 *      				0xFFFFFFFD <-> Return to Thread mode, Exception return gets state from process stack, execution uses PSP after return
 *      				All other values <-> Reserved
 *
 *   Exercise:
 */

#include<stdio.h>
#include<stdint.h>

/* This function executes in THREAD MODE of the processor */
void generate_interrupt()
{
	uint32_t *pSTIR  = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	//enable IRQ3 interrupt
	*pISER0 |= ( 1 << 3);

	//generate an interrupt from software for IRQ3
	*pSTIR = (3 & 0x1FF);

}

/* This function executes in THREAD MODE+ PRIV ACCESS LEVEL of the processor */
int main(void)
{
	printf("In thread mode : before interrupt\n");

	generate_interrupt();

	printf("In thread mode : after interrupt\n");

	for(;;);
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void RTC_WKUP_IRQHandler(void)
{
	printf("In handler mode : ISR\n");
}
