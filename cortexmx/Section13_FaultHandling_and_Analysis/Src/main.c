/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * 		__Fault Handlers__
 *
 * 	What is a fault?
 * 	. The fault is an exception generated by the processor (system exception) to indicate an error.
 *
 * 	Why does a fault happen?
 * 	. Faults happen because of programmers violating the design rules of handling a processor or the interfaces with which the processor deals with.
 *  . Whenever a fault happens, internal processor registers will be updated to record the type of fault, the address of instruction at which the fault happened,
 *    and if an associated exception is enabled, the exception handler will be called by the processor.
 *  . In the exception handler programmers may implement the code to report, resolve, or recover from the fault.
 *  . For example, if your code tries to divide a number by zero, then divide by 0 fault will be raised from the hardware, which will invoke usage fault
 *    exception handler (if enabled). In the exception handler, you may make certain decisions to get rid of the problem, like closing the task, etc.
 *  . Most of the time, fault happens by programmer's code not adhering to processor programming guidelines.
 *
 *	There are 9 system exceptions implemented in the processor.
 *	Reset (highest priority), NMI, and HardFault exceptions have fixed (non-configurable) priority values.
 *	HardFault, MemManage, BusFault, UsageFault are Fault Exceptions. These should all be taken care of by the programmer.
 *
 *	Hard fault exception*   {enabled by default, non-configurable priority}  Can disable using FAULTMASK register.
 *	Usage fault exception         }
 *	Mem manage fault exception    } Disabled by default, configurable priority.
 *	Bus fault exception           }
 *
 *	Causes of fault
 *	. Divide by zero (if enabled)
 *	. Undefined instruction
 *	. Attempt to execute code from memory region which is marked as execute never (XN) to prevent code injection
 *	. MPU guarded memory region access violation by the code
 *	. Unaligned data access (if enabled)
 *	. Returning to thread mode keeping active interrupt alive
 *	. Bus error (example no response from memory device (e.g., SDRAM))
 *	. Executing SVC instruction inside SVC handler or calling a function in SVC handler which eventually execute hidden SVC instruction
 *	. Debug monitor settings and related exceptions
 *
 *		__Hard-fault Exception__
 *	A HardFault is an exception that occurs because of an error during exception processing, or because an exception cannot be managed by any other exception
 *	mechanism. It has 3rd highest fixed priority (-1) after reset and NMI meaning it has higher priority than any exception with configurable priority.
 *
 *	Causes:
 *	1) Escalation of configurable fault exceptions
 *	2) Bus error returned during a vector fetch
 *	3) Execution of break point instruction when both halt mode and debug monitor is disabled
 *	4) Executing SVC instruction inside SVC handler
 *
 *							__Flow Chart__
 *
 *									|  Configurable exceptions (usage, mem manage, bus fault)
 *				 yes				v				      no
 *				 -- [Is configurable exception enabled?]  ->   [Hardfault Handler]
 *				|							    Escalated to hardfault (FORCED)
 *				v
 *	[Handled by configurable exception handlers]
 *
 *
 *	[Bus fault during vector fetch from vector table]  ----------->  [Hardfault handler]
 *												Always escalated to hardfault
 *
 *
 *	Also,
 *	         Thread Mode				    Handler Mode			   Handler Mode
 *	[Execution of SVC instruction] -> [Execute SVC instruction] -> [Hard-fault handler]
 *											SVC Handler
 *
 *				__HardFault Status Register (HFSR)__
 *		This register is read, write to clear. This means that bits in this register read normally, but writing 1 to any bit clears that bit to 0.
 *
 *		Bits	Name		Function
 *		[31]	DEBUGEVT	Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is unpredictable.
 *		[30]	Forced		Indicates a forced hard fault, generated by escalation of a fault with config priority that cannot be handled, either b/c of priority or b/c disabled:
 *							0 = no forced HardFault
 *							1 = forced HardFault
 *							When this bit is set to 1, the HardFault handler must read the other fault status registers to find the cause of the fault.
 *		[29:2]	-			Reserved
 *		[1]		VECTTBL		Indicates a BusFault on a vector table read during exception processing:
 *							0 = no BusFault on vector table read
 *							1 = BusFault on vector table read
 *							This error is always handled by the hard fault handler.
 *							When this bit is set to 1, the PC value stacked for the exception return points to the instruction that was preempted by the exception.
 *		[0]		-			Reserved
 *
 *
 *		__Mem Manage Fault Exception__
 *	. This is a configurable fault exception. Disabled by default.
 *	. You can enable this exception by configuring the processor register "System Handler Control and State Register (SHCSR)"
 *	. When mem manage fault happens, mem manage fault exception handler will be executed by the processor.
 *	. Priority of this fault exception is configurable.
 *
 *	4.3.9 System Handler Control and State Register
 *		The SHCSR enables the system handlers, and indicates:
 *		. The pending status of BusFault, MemManage fault, and SVC exceptions
 *		. The active status of the system handlers
 *
 *	Causes of mem manage fault exception:
 *	1) As its name indicates, this fault exception triggers when memory access violation is detected (access permission by the processor or MPU)
 *	2) Unprivileged thread mode code (such as user app or RTOS task) tries to access a memory region which is marked as "privilege access only" by the MPU
 *	3) Writing to memory regions which are marked as read-only by the MPU4
 *	4) This fault can also be triggered when trying to execute program code from "peripheral" memory regions. Peripheral memory regions are marked as XN (eXecute Never)
 *	   regions by the processor design to avoid code injection attacks through peripherals.
 *
 *	Causes of Bus-fault exception:
 *	1) Due to error response returned by the processor bus interfaces during access to memory devices (during instruction fetch or during data read/write to memory devices).
 *	2) If bus error happens during vector fetch, it will be escalated to a hard fault even if bus fault exception is enabled.
 *	3) Memory device sends error response when the processor bus interface tries to access invalid or restricted memory locations which could generate a bus fault.
 *	4) When the device is not read to accept memory transfer.
 *	5) You may encounter such issues when you play with external memories such as SDRAM connected via DRAM controllers.
 *	6) Unprivileged access to the private peripheral bus.
 *
 *	Usage Fault exception:
 *	. This is a configurable fault exception. Disabled by default
 *	. You can enable this exception by configuring the processor register "System Handler Control and State Register (SHCSR)"
 *	. When usage fault happens, the processor executes usage fault exception handler.
 *	. Priority of this fault exception is configurable.
 *		Causes:
 *	1) Execution of undefined instruction (Cortex M4 supports only Thumb ISA, so executing any instruction outside this ISA (like ARM ISA) would result in a fault).
 *	2) Executing floating point instruction keeping floating point unit disabled.
 *	3) Trying to switch to ARM state to execute ARM ISA instructions. The T bit of the processor decides ARM state or THUMB state. For Cortex M it should be maintained at 1.
 *	   Making T bit 0 (may happen during function call using function pointers whose 0th bit is not maintained as 1) would result in a fault.
 *	4) Trying to return to thread mode when an exception/interrupt is still active.
 *	5) Unaligned memory access with multiple load or multiple store instructions.
 *	6) Attempt to divide by zero (if enabled, by default divide by zero results in zero)
 *	7) For all unaligned data access from memory (only if enabled, otherwise Cortex M supports unaligned data access)
 *
 *	Exercise:
 *	Write a program to enable all configurable fault exceptions, implement the fault exception handlers and cause the fault by following method:
 *	1) Execute an undefined instruction
 *	2) Divide by zero
 *	3) Try executing instruction from peripheral region
 *	4) Execute SVC inside the SVC handler
 *	5) Executing SVC instruction inside the interrupt handler whose priority is the same or lesser than SVC handler.
 *
 *		__Fault Status and Address Information__
 *	When a fault happens, inside the fault handler, you can check a couple of fault status and address information registers to get more details about the fault and
 *	the instruction address at which the fault happened. This will be helpful for debugging.
 *
 *	Handler		Status Reg Name		Address Reg Name	Register Description
 *	--------------------------------------------------------------------------
 *	HardFault		HFSR				-				Page 4-30
 *	Mem Manage		MMFSR				MMFAR			Page 4-25 and 4-30
 *	BusFault		BFSR				BFAR			Page 4-26 and 4-31
 *	UsageFault		UFSR				-				Page 4-28
 *
 *		__Analyzing Stack Frame__
 *	Thread mode instruction causes exception to trigger which transitions state from Thread Mode to Handler Mode (Exception Handler is entered: Usage Fault Handler in this case).
 *	When exception is triggered, stacking of thread mode context begins. The stack frame will be stored (pushed) in the stack (Descending stack in this case). The stack frame includes:
 *
 *	SP(MSP) (Top of Stack after exception triggers)                                    SP(MSP) (Top of Stack before exception)
 *   V	---------------------------------------[Stack Frame]-------------------------------------		      V
 *	    [R0(SP-32), R1(SP-28), R2(SP-24), R3(SP-20), R12(SP-16), LR(SP-12), PC(SP-8), XPSR(SP-4)] (Previous Stack Content)
 *
 *
 *			(Assembly Functions)
 *		__attribute__((naked)) functions
 *
 * . This attribute tells the compiler that the function is an embedded assembly function. You can write the body of the function entirely in assembly code using __asm statements.
 * . The compiler does not generate prologue and epilogue sequences for functions with __attribute__((naked))
 * . Use naked functions only to write some assembly instructions(__asm statements).  Mixing 'C' code might not work properly.
 *
 *
 *		__Error reporting when fault happens__
 *	. Implement the handler which takes some remedial actions
 *	. Implement a user call back to report errors
 *	. Reset the microcontroller/processor
 *	. For an OS environment, the task that triggered the fault can be terminated and restarted
 *	. Report the fault status register and fault address register values
 *	. Report additional information of stack frame through debug interface such as printf
 *
 */

#include <stdio.h>
#include <stdint.h>

void UsageFaultHandler_c(uint32_t *pMSP);

int main(void)
{
	//1. Enable all configurable exceptions like usage fault, mem manage fault, and bus fault
		//search system control block in cortex m4 user guide
		//look for system handler control and state register (SHCRS **typo in manual)
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= (1 << 16); //mem manage
	*pSHCSR |= (1 << 17); //bus fault
	*pSHCSR |= (1 << 18); //usage fault



	//3. lets force the processor to execute some undefined instructions
	uint32_t *pSRAM = (uint32_t*)0x20010000; //random memory location of SRAM
	*pSRAM = 0xFFFFFFFF; 		 //invalid OPCODE

	void (*some_address) (void); //function pointer variable

	//some_address = (void*)pSRAM; 						 //initialize function pointer to address (actually incorrect to do this)
	some_address = (void*) 0x20010001;  				 //address of a function should ALWAYS be odd (t-bit needs to be 1 to keep it in THUMB state and not ARM state).
	//some_address = (void*)( (uint32_t)pSRAM) + 1 );    //or you can typecast and add 1 to the address
	some_address(); 			 //dereference function pointer (how to jump to location in memory) or make PC loaded with that address

	//4. analyze the faults

	for(;;);
}


//2. implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : HardFault\n");
	while(1);
}

void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}

//caller
__attribute__((naked)) void UsageFault_Handler(void){
	//here we extracted the value of MSP which happens to be the base address
	//of the stack frame which got saved during the exception entry from thread mode to handler mode.
	__asm ("MRS r0, MSP");
	__asm ("B UsageFault_Handler_c"); //branch to c function
}

//callee (value of r0 from caller becomes argument 1 in callee function)
void UsageFault_Handler_c(uint32_t *pBaseStackFrame)
{
	// moved these instructions to the naked function above (diff way to do it)
	//__asm ("MRS r0, MSP");
	//register uint32_t msp_value __asm("r0");
	//uint32_t *pMSP = (uint32_t*)msp_value;

	uint32_t *pUFSR = (uint32_t*)0xE000ED2A;
	printf("Exception : UsageFault\n");
	printf("UFSR = %lx\n", (*pUFSR) & 0xFFFF); //read first 16 bits of UFSR register
	//printf("MSP = %p\n", pMSP); //read MSP register

	//print contents of stack frame
	printf("pBaseStackFrame = %p\n", pBaseStackFrame); //read Base of Stack Frame
	printf("Value of R0 = %lx\n", pBaseStackFrame[0]); //read R0 register
	printf("Value of R1 = %lx\n", pBaseStackFrame[1]); //read R1 register
	printf("Value of R2 = %lx\n", pBaseStackFrame[2]); //read R2 register
	printf("Value of R3 = %lx\n", pBaseStackFrame[3]); //read R3 register
	printf("Value of R12 = %lx\n", pBaseStackFrame[4]); //read R12 register
	printf("Value of LR = %lx\n", pBaseStackFrame[5]); //read LR register
	printf("Value of PC = %lx\n", pBaseStackFrame[6]); //read PC register
	printf("Value of XPSR = %lx\n", pBaseStackFrame[7]); //read XPSR register
	while(1);
}
