/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdio.h>
#include<stdint.h>

/*
 *  __NVIC (Nester Vector Interrupt Controller) Discussion__
 *  1) NVIC is one of the peripherals of the Cortex M processor core.
 *  2) It is used to configure the 240 interrupts.
 *  3) Using NVIC registers you can enable/disable/pend various interrupts and read the status of the active and pending interrupts.
 *  4) You can configure the priority and priority grouping of various interrupts.
 *  5) Its called "Nested" because, it supports pre-empting a low priority interrupt handler when higher priority interrupt arrives.
 *
 *	__Enable/Disable/Pend various interrupts using NVIC register__
 *	1) Cortex M processor supports 240 interrupts
 *	2) These interrupts are managed and configured using NVIC
 *	3) What are those 240 interrupts?
 *	   This is highly vendor specific and it is triggered by various on-chip peripherals of the MCU like SPI, gpios, CAN, timers, dmas, etc.
 *	   STM32F446 MCU delivers 97 different (IRQ) interrupts to the processor
 *
 *	  32bit registers
 *	ISER (Interrupt Set-enable Registers) = set interrupts
 *	ICER (Interrupt Clear-enable Registers) = clear interrupts
 *	ISPR (Interrupt Set-pending Registers) = pend interrupts
 *	ICPR (Interrupt Clear-pending Registers) = clear pending interrupts
 *	IABR (Interrupt Active Bit Registers) = used to check interrupt active flags
 *
 *
 *	Exercise:
 *	Enabling and Pending of USART3 Interrupt (IRQ39 of NVIC)
 *
 *	Steps to program an MCU peripheral interrupt
 *	. Identify the IRQ number of the peripheral by referring to the MCU vector table. IRQ numbers are vendor-specific
 *	. Program the Processor register to enable the IRQ (only when you enable the IRQ, the processor will accept the interrupt over that line). Set priority (optional)
 *	. Configure the peripheral (USART3) using its peripheral configuration register. For example, in the case of USART3, whenever a packet is received,
 *	  it will automatically issue an interrupt on the IRQ line 39.
 *	. When the interrupt is issued on the IRQ line, it will first get pended in the pending register of the processor.
 *	. NVIC will allow the IRQ handler associated with the IRQ number to run only if the priority of the new interrupts higher than the currently executing interrupt handler.
 *	  Otherwise newly arrived interrupt will stay in pending state.
 *	. Please note that if peripheral issues an interrupt when the IRQ number is disabled (not activated from the processor side), then still interrupt will get pended in
 *	  the pending register of the NVIC. As soon as IRQ is enabled, it will trigger the execution of the ISR if the priority is higher than the currently active ISR.
 *
 *	 1) lets say Data packet arrives from external world into the USART peripheral buffer [USART RX buffer]
 *	 2) USART peripheral issues an interrupt
 *	 3) NVIC: Interrupt pends in the pending register of the NVIC (IRQ enable = 1)
 *	 4) CPU: 1) fetches the ISR address from the vector table
 *	         2) PC jumps to ISR
 *	 5) ISR: Copies data from RX buffer to SRAM
 */

#define USART3_IRQNO 39

int main(void)
{
	//1. Manually pend the pending bit for the USART3 IRQ number in NVIC
	//IRQ39 == USART3  so we have to use ISPR1 register since ISPR0 includes IRQ[31:0] while ISPR1 includes IRQ[63:32]
	uint32_t *pISPR1 = (uint32_t*)0xE000E204;
	*pISPR1 |= (1 << (USART3_IRQNO % 32));    //sets 7th bit of ISPR1 (39 % 32 = 7)

	//2. Enable the USART3 IRQ in NVIC
	uint32_t *pISER1 = (uint32_t*)0xE000E104;
	*pISER1 |= (1 << (USART3_IRQNO % 32));

	for(;;);
}

//USART3 ISR
void USART3_IRQHandler(void)
{
	printf("in USART3 isr\n");
}
