/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 *		__Exceptions for system-level services__
 *	. ARM cortex MX processor supports 2 important system-level service exceptions.
 *		. SVC (SuperVisor Call) and PendSV (Pendable SerVice)
 *	. Supervisory calls are typically used to request privileged operations or access to system resources from an operating system.
 *	. SVC exception is mainly used in an OS environment. For example, A less privileged user task can trigger SVC exception
 *	  to get system-level services (like accessing device drivers, peripherals) from the kernel of the OS.
 *	. PendSV is mainly used in an OS environment to carry out context switching between 2 or more tasks when no other exceptions
 *	  are active in the system.
 *
 *		__SVC (Supervisor Call) instruction__
 *	. SVC is a thumb ISA instruction which causes SVC exception
 *	. In an RTOS scenario, user tasks can execute SVC instruction with an associated argument to make supervisory calls to seek privileged resources from the kernel code.
 *	. Unprivileged user tasks use the SVC instruction to change the processor mode to privileged mode to access privileged resources like peripherals.
 *	. SVC instruction is always used along with a number, which can be used to identify the request type by the kernel code.
 *	. The SVC handler executes right after the SVC instruction (no delay. Unless a higher priority exception arrives at the same time).
 *
 *	Scenario:
 *
 *	1) User level code. User task SVC #1. Access level: unprivileged. Processor mode: Thread.
 *	2) Kernel level code. __SVC_request_handler(int svc_number) {}. Access level: privileged. Processor mode: Handler.
 *	3) (from SVC_request_handler) Privileged resource (display). Peripheral registers access is protected by MPU (memory protection unit) (privileged access only)
 *		a.) Memory Manage Fault Exception would be triggered if the User Task tries to change / write registers of protected peripheral directly.
 *
 *		__Methods to trigger SVC exception__
 *	There are two ways:
 *	1) Direct execution of SVC instruction with an immediate value. Example: 'SVC #0x04' in assembly (Using SVC instruction is very efficient in terms of latency)
 *	2) Setting the exception pending bit in "System Handler Control and State Register" (uncommon method)
 *
 *		__How to extract the SVC number__
 *	. The SVC instruction has a number embedded within it, often referred to as the SVC number.
 *	. In the SVC handler, you should fetch the opcode of the SVC instruction and then extract the SVC number.
 *	. To fetch the opcode of the SVC instruction from program memory, we should have the value of PC (return address) where the user code had interrupted while triggering
 *	  the SVC exception.
 *	. The value of the PC (return address) where the user code had interrupted is stored in the stack as a part of exception entry sequence by the processor.
 *
 *	Basically, when SVC triggers from Task A, processor moves from Thread mode (MSP) to Handler mode (MSP) and the stacking process occurs. When in the SVC handler,
 *	you want to extract the SVC number from the stack frame.
 *		To do this:
 *		Next_ins_addr_after_svc = MSP[6]. PC is located by adding '6' to the location of MSP.
 *		SVC_number = *( (Next_ins_addr_after_svc) - 2)  //This gives the address, where SVC instruction is stored in code memory. You subtract two because it is pointing to the next location.
 *
 *
 *	Exercise:
 *	Write a program to execute an SVC instruction from thread mode, implement the SVC handler to print the SVC number used. Also, increment the SVC number by 4 and return it to the thread mode
 *	code and print it.
 *	Hints:
 *	1) Write a main() function where you should execute the SVC instruction with an argument. Lets say SVC #0x5
 *	2) Implement the SVC handler
 *	3) In the SVC handler extract the SVC number and print it using printf
 *	4) Increment the SVC number by 4 and return it to the thread mode.
 *
 *
 *	We are using stack frame to pass the message (svc number) when going between handler mode and thread mode. the return value comes from r0, which we populated with the value we wanted.
 */

#include <stdio.h>
#include <stdint.h>

void SVC_Handler_c(uint32_t*);

//Exercise SVC Number
//Thread Mode code
int main(void)
{
	__asm volatile ("SVC #0x08");

	//register uint32_t data __asm("r0"); //if you do this, the variable data will not be created in stack but rather in a register (not recommended tho)

	uint32_t data;

	__asm volatile ("MOV %0, R0" : "=r"(data) ::);

	printf("data = %ld\n", data);

	for(;;);
}

__attribute__((naked)) void SVC_Handler(void)
{
	//1. Get the value of the MSP
	__asm("MRS R0, MSP"); //get MSP value without prologue/epilogue instructions modifying it
	__asm("B SVC_Handler_c"); //branch to c function
}

//Handler Mode code
void SVC_Handler_c(uint32_t *pBaseOfStackFrame)
{
	printf("in SVC handler\n");

	//__asm("MRS R0, MSP"); //executing this while in a c function can give a corrupted MSP value because of prologue/epilogue instructions included with a C function. (use naked func)
	uint8_t *pReturn_addr = (uint8_t*)pBaseOfStackFrame[6];

	//2. decrement the return address by 2 to point to opcode of the SVC instruction in the program memory
	pReturn_addr -= 2;

	//3. Extract the SVC number
	uint8_t svc_number = *pReturn_addr;
	printf("SVC number is : %d\n", svc_number);

	//4. Increment the SVC number by 4 and return it to thread mode
	svc_number += 4;
}
