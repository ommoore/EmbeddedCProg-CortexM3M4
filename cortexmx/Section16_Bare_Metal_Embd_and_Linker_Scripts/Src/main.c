/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 *			__Building and running bare metal executables for ARM target using GNU tools__
 *	. Toolchain installation
 *	. Understand compiling a 'C' program for an embedded target without using an IDE
 *	. Writing microcontroller startup file for STM32F4 MCU
 *	. Writing your own 'C' startup code (code which runs before main() )
 *	. Understanding different sections of the relocatable object file (.o files)
 *	. Writing linker script file from scratch and understanding section placements
 *	. Linking multiple .o files using linker script and generating application executable (.elf, bin, hex)
 *	. Loading the final executable on the target using OpenOCD and GDB client
 *
 *
 *  ~~~~~~~~~~~~Developing~~~~~~~~~~	 ~~~~~~~~Building~~~~~~	   ~~~~~~~Downloading~~~~~~~	~~~Running~~~
 *	[User application (.c, .s files)] -> [Compiler] -> [Linker] -> [Programmer and debugger] -> [Flash (MCU)]
 *
 *	1st. Using  Sample "C" program from Section 15 (task_scheduler)
 *	Took main.c, main.h, led.c, led.h and put in a folder called my_workspace
 *
 *		__Cross compilation and toolchains__
 *			(High Level Language)		(Embedded target specific machine codes)
 *	[User application (.c, .s files)] -------------> [Executable]
 *
 *	What is cross compilation?
 *	. Cross-compilation is a process in which the cross-toolchain runs on the host machine (PC) and creates executables that run on different machine (ARM)
 *
 *	Cross-compilation toolchains
 *	. Toolchain or a cross-compilation toolchain is a collection of binaries which allows you to compile, assemble, link your applications
 *	. It also contains binaries to debug the application on the target
 *	. Toolchain also comes with other binaries which help you to analyze the executables
 *		. dissect different sections of the executable
 *		. disassemble
 *		. extract symbol and size information
 *		. convert executable to other formates such as bin, ihex
 *		. provides 'C' standard libraries
 *
 *	Popular Toolchains:
 *	1. GNU Tools (GCC) for ARM Embedded Processors (free and open-source)
 *	2. armcc from ARM Ltd. (ships with KEIL, code restriction version, requires licensing)
 *
 *	We will be using GNU's Compiler Collections (GCC) Toolchain
 *
 *	arm-none-eabi-gcc (compiler, linker, assembler)
 *	arm-none-eabi-objdump, arm-none-eabi-readelf, arm-none-eabi-nm (Elf file analyzer)
 *	arm-none-eabi-ld (linker)
 *	arm-none-eabi-as (assembler)
 *	arm-none-eabi-objcopy (format converter)
 *
 *		__Build process__
 *
 *	main.c -> [Compiler] -> main.i
 *		(pre-processing stage of compilation)
 *		*all pre-processing directives will be resolved
 *
 *	main.i -> [Compiler] -> main.s
 *		(Code generation stage)
 *		Higher level language code statements will be converted into processor architectural level mnemonics
 *
 *							(re-locatable object file)
 *	main.s -> [Compiler] -> main.o
 *		(Assembler stage)
 *		Assembly level mnemonics are converted into opcodes (machine codes for instructions)
 *
 *	main.c -> (pre-processing) -> main.i -> (parsing) -> (code generator) -> main.s -> (assembler) -> main.o
 *
 *	re-locatable basically means no absolute addresses when the high level 'c' code is translated into assembly level, processor architecture specific machine codes.
 *
 *	by default, the processor does not save the .i and .s files but you can tell it to save them if you like.
 *
 *
 *	After all that, Linking Stage:
 *
 *	re-locatable object files (.o)
 *	  |				Executable and debug file
 *	  |						|
 *	main.o -> (Linker) -> main.elf -> objcopy tool
 *				 |							|	 |
 *			   main.a					.ihex   .bin
 *  Other libraries (std and/or 3rd party)
 *
 *	(.elf stands for executable and linkable format)
 *
 *	Complete build process:  Pre-processing -> Compilation -> Linking   (arm-none-eabi-gcc)
 *
 *
 *	__Compiling main.c in command prompt__
 *
 *	arm-none-eabi-gcc main.c -o main.o   (this compiles, assembles and links. but we don't want to link, just compile.)
 *
 *	so instead:  arm-none-eabi-gcc -c main.c -o main.o  (compile and assemble but dont link).
 *
 *	check http://gcc.gnu.org/onlinedocs/gcc/index.html
 *
 *	inline assembly codes will fail because we did not specify the processor architecture to the compiler.
 *
 *	so instead do: arm-none-eabi-gcc -c -mcpu=cortex-m4 main.c -o main.o
 *
 *	but also, we need to specify -mthumb flag so the compiler generates code in Thumb state rather than ARM state. Cortex M processsors only support Thumb State.
 *
 *	arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb main.c -o main.o
 *	arm-none-eabi-gcc -S -mcpu=cortex-m4 -mthumb main.c -o main.s (compile but do not assemble)
 *
 *	__MakeFile__
 *
 *	target:dependency
 *	main.o:main.c
 *
 *	$^ -> denotes dependency  (main.c)
 *	$@ -> denotes target      (main.o)
 *	$(var)
 *
 * 		__Analyzing .o files (Relocatable object files)__
 * 	. main.o is in elf format (executable and linkable format)
 * 	. ELF is a standard file format for object files and executable files when you use GCC
 * 	. A file format standard describes a way of organizing various elements (data, read-only data, code, uninitialized data, etc.) of a program in different sections.
 *
 *	Other file formats:
 *		. The Common Object File Format (COFF): Introduced by Unix System V
 *		. ARM Image Format (AIF) : Introduced by ARM
 *		. SRECORD: Introduced by Motorola
 *
 *	__Analyzing object file__
 *
 *	arm-none-eabi-objdump.exe
 *  arm-none-eabi-objdump.exe -h main.o
 *
 *	arm-none-eabi-objdump.exe -d main.o > main_log
 *	arm-none-eabi-objdump.exe -D main.o > main_log
 *	arm-none-eabi-objdump.exe -s main.o
 *
 *	 Source File				Relocatable object file
 *	  [main.c]  --------------------> [main.o]
 *	   _ | _	    Compilation			Machine code file. It doesnt contain any absolute addresses for data and code
 *	 |		 |
 *	Code	Data
 *
 *	Instructions (codes) are stored in FLASH memory of the MCU.
 *	Data (variables) are stored in the main memory (RAM)
 *	Why is data stored in RAM but not in FLASH>
 *	Because, data is nothing but variables and they may change at anytime during runtime of the program.
 *	So, it makes sense to store read only data in flash but not variable data.
 *
 *	Flash 	R   memory
 *	RAM 	R/W memory
 *
 *
 *
 *		contains initialized data									This section contains code (instructions)
 *	RAM		  [.data] <------------------------------------------------------------>[.text] 					  ROM
 *	  												|
 *		contains read only data	____________________|_____________	contains data/code which programmer demands to put in user defined sections
 *	ROM		[.rodata] <------------[main.o (object file in ELF format)]------------>[user defined sections]       RAM or ROM
 *													|
 *		contains data which are uninitialized		|				some special sections added by the compiler. contains some special data
 *	RAM 	   [.bss] <------------------------------------------------------------>[some special sections]       ROM
 *								Different sections of the program in an ELF format
 *
 *				__Linker and Locator__
 *
 *	[main.c]  --------------->  [main.o] {.text, .data, .bss, .rodata}
 *	 [led.c]  --------------->  [main.o] {.text, .data, .bss, .rodata}
 *
 *	Linker and Locator:
 *		. Use the linker to merge similar sections of different object files and to resolve all undefined symbols of different object files.
 *		. Locator (part of linker) takes the help of a linker script to understand how you wish to merge different sections and assigns mentioned
 *		  addresses to different sections.
 *
 *																Merging and address relocation
 *   Done by linker and locator			 (executable)		.text   ---->   .text(main.o),   .text(led.o)
 *   with the help of linker script  {   [final.elf]   {	.data   ---->   .data(main.o),   .data(led.o)    }
 *   provided by you										.bss    ----> 	 .bss(main.o),    .bss(led.o)
 *															.rodata ----> .rodata(main.o), .rodata(led.o)
 *
 *			Storage of final executable in code memory (ROM or FLASH)
 *						_______________________
 *						|				      |
 *						| Unused code memory  |
 *						|				      |
 *						|				      |
 *						|_____________________|
 *						|				      |
 *						|		.data         |
 *						| (initialized global |
 *						| & static variables) |
 *						|                     |  } Code memory (FLASH)
 *						|_____________________|
 *						|      .rodata        |
 *						|_____________________|
 *						|	   	     		  |
 *						|       .text         |
 *						|                     |
 *						|_____________________|
 *		0x0800_0000		|	  Vector Table    |
 *
 *
 *   		 //Copy .data (data copy) from FLASH to SRAM
 *
 *						   Data Memory (SRAM)
 *					    _______________________
 *						|				      |
 *						| 		 stack        |
 *						|				      |
 *						|				      |
 *						|_____________________|
 *						|				      |
 *						|	  Unused SRAM 	  |
 *						|                     |
 *						|_____________________|
 *						|     	 heap	      |
 *						|_____________________|
 *						|	   	 .bss         |
 *						|(uninitialized global|
 *						|and static variables)|
 *						|_____________________|
 *						|		.data		  |
 *						|(initialized global  |
 *		0x2000_0000		|and static variables)|
 *
 *			//transferring of .data section to RAM ( done by 'C' start-up code )
 *
 *	Since un-initialized variables dont carry any useful data to "remember", why would you store in FLASH and waste memory?
 *	So, Compiler doesnt include those variables as part of .data section.
 *
 *	global initialized should be stored in ROM.
 *
 *	local data stored in stack.
 *
 *							(LMA)		(VMA) - virtual memory address
 *	Variable				LOAD time	RUN time	Section		Note
 *	--------------------------------------------------------------------------------------------------------
 *	Global initialized		FLASH		RAM			.data		Should be copied from flash to ram by startup code
 *	Global uninitialized	-----		RAM			.bss		Startup code reserves space for this data in RAM and initializes to zero
 *	Global static init.		FLASH		RAM			.data		Should be copied from flash to ram by startup code
 *	Global static uninit.	-----		RAM			.bss		Startup code reserves space for this data in RAM and initializes to zero
 *	Local initialized		-----		STACK(RAM)	-----		Consumed at run time
 *	Local uninitialized		-----		STACK(RAM)	-----		Consumed at run time
 *	Local static init.		FLASH		RAM			.data		Should be copied from flash to ram by startup code
 *	Local static uninit.	-----		RAM			.bss		Startup code reserves space for this data in RAM and initializes to zero
 *	All global const		FLASH		-----		.rodata
 *	All local const			-----		STACK(RAM)	-----		Treated as locals
 *
 *		__.bss (block started by symbol) and .data section__
 *	. All the uninitialized global variables and uninitialized static variables are stored in the .bss section.
 *	. Since those variables do not have any initial values, they are not required to be stored in the .data section since the .data section
 *	  consumes FLASH space. Imagine what would happen if there is a large global uninitialized array in the program, and if that is kept
 *	  in the .data section, it would unnecessarily consume flash space yet carries no useful information at all.
 *	. .bss section doesn't consume any FLASH space unlike the .data section
 *	. You must reserve RAM space for the .bss section by knowing its size and initialize those memory space to zero. This is typically done
 *	  in startup code.
 *	. Linker helps you to determine the final size of the .bss section. So, obtain the size information from a linker script symbols.
 *
 *
 *		__Importance of start-up file__
 *	. The startup file is responsible for setting up the right environment for the main user code to run.
 *	. Code written in startup file runs before main(). So, you can say startup file calls main().
 *	. Some part of the startup code file is the target (processor) dependent.
 *	. Startup code takes care of vector table placement in code memory as required by the ARM cortex MX processor.
 *	. Startup code may also take care of stack reinitialization.
 *	. Startup code is responsible of .data, .bss section initialization in main memory.
 *
 *		Writing Start-up File
 *	1. Create a vector table for your microcontroller. Vector tables are MCU specific.
 *	2. Write a start-up code which initializes .data and .bss section in SRAM.
 *	3. Call main()
 *
 *					__Vector Table for STM32F446xx__
 *				  (97 IRQ's (IRQ0-IRQ96), 15 system exceptions, MSP)
 *
 *					Total memory consumed by VT
 *					97 + 15 + 1 = word addressable memory locations
 *						113 * 4 = 452 bytes
 *	 				    _______________________
 *						|Addr of IRQ96 handler|  0x0800_01C0
 *						|_____________________|
 *						|Addr of IRQ95 handler|  0x0800_01BC
 *						|_____________________|
 *						|Addr of IRQ94 handler|  0x0800_01B8
 *						|_____________________|
 *						|	 	  			  |
 *						|                     |
 *						|         ...         |
 *						|     	    	      |
 *						|_____________________|
 *						|  Addr of hardfault  |  0x0800_000C
 *					    |     handler         |
 *						|_____________________|
 *						| Addr of NMI handler |  0x0800_0008
 *						|_____________________|
 *						|Addr of reset handler|  0x0800_0004
 *						|_____________________|
 *						|  Initial MSP value  |  0x0800_0000
 *
 *	Creating a Vector Table:
 *		. Create an array to hold MSP and handlers addresses.
 *				uint32_t vectors[] = {store MSP and address of various handlers here};
 *		. Instruct the compiler not to include the above array in .data section but in a different user defined section.
 *
 *  __attribute__((section(".isr_vector")))
 *  //check sections after defining ".isr_vector" section in startup code so it doesn't get put into .data or .bss
 *		arm-none-eabi-objdump.exe -h stm32_startup.o
 *
 *	Function Attribute: Weak and Alias
 *		Weak: Lets programmer override already defined weak function (dummy) with the same function name
 *	    Alias: Lets programmer to give alias name for a function
 *
 *		__LINKER SCRIPT__
 *	Transferring of .data section to RAM ('C' start-up)
 *	Need to know boundaries:  _edata, _sdata, _etext etc.
 *
 *	. Linker script is a text file which explains how different sections of the object files should be merged to create an output file.
 *	. Linker and locator combination assigns unique absolute addresses to different sections of the output file by referring to address information mentioned
 *	  in the linker script.
 *	. Linker script also includes the code and data memory address and size information.
 *	. Linker scripts are written using the GNU linker command language.
 *	. GNU linker script has the file extension of .ld
 *	. You must supply linker script at the linking phase to the linker using -T option.
 *
 *	Linker script commands:
 *	ENTRY, MEMORY, SECTIONS, KEEP, ALIGN, AT>
 *
 *	Entry command:
 *	. This command is used to set the "Entry point address" information in the header of final elf file generated.
 *	. In our case, "Reset_Handler" is the entry point into the application. The first piece of code that executes right after
 *	  the processor reset.
 *	. The debugger uses this information to locate the first function to execute.
 *	. Not a mandatory command to use, but required when you debug the elf file using the debugger (GDB)
 *	. Syntax: Entry(_symbol_name_)
 *	  Entry(Reset_Handler)
 *
 *  Memory command:
 *  . This command allows you to describe the different memories present in the target and their start address and size information.
 *  . The linker uses information mentioned in this command to assign addresses to merged sections.
 *  . The information is given under this command also helps the linker to calculate total code and data memory consumed so far
 *    and throw an error message if data, code, heap or stack areas cannot fit into available size.
 *  . By using memory command, you can fine-tune various memories available in your target and allow different sections
 *    to occupy different memory areas.
 *  . Typically one linker script has one memory command.
 *  . Syntax:
 *    MEMORY
 *    {
 *    	name(attr) : ORIGIN = origin, LENGTH = len
 *    }
 *
 *	. Attributes:
 *		R		Read-only sections
 *		W		Read and write sections
 *		X		Sections containing executable code.
 *		A		Allocated sections
 *		I		Initialized sections
 *		L		Same as 'I'
 *		!		Invert the sense of any of the following attributes
 *
 *	. STM32F446RE      Flash Size (512kB)  SRAM1 Size (112kB)   SRAM2 Size (16kB)
 *
 *	Sections command:
 *	. SECTIONS command is used to create different output sections in the final elf executable generated.
 *	. Important command by which you can instruct the linker how to merge the input sections to yield an output section.
 *	. This command also controls the order in which different output sections appear in the elf file generated.
 *	. By using this command, you also mention the placement of a section in a memory region. For example, you instruct the linked
 *	  to place the .text section in the FLASH memory region, which is described by the MEMORY command.
 *	. >(vma)AT>(lma)   virtual memory address AT> load memory address
 *
 *	Location counter (.)
 *	. This is a special linker symbol denoted by a dot '.'
 *	. This symbol is called "location counter" since linker automatically updates this symbol with location(address) information.
 *	. You can use this symbol inside the linker script to track and define boundaries of various sections.
 *	. You can also set location counter to any specific value while writing linker script.
 *	. Location counter should appear only inside the SECTIONS command.
 *	. The location counter is incremented by the size of the output section.
 *	. Location counter always tracks VMA (virtual memory address) not LMA (load memory address)
 *
 *	Linker script symbol:
 *	. A symbol is the name of an address
 *	. A symbol declaration is not equivalent to a variable declaration what you do in your 'C' application.
 *	. Compiler maintains a symbol table in the .o file.
 *
 *  command in cmd:
 *  arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o final.elf
 *
 *  to see all symbols:
 *  arm-none-eabi-nm.exe final.elf
 *
 *
 *		__Downloading and Debugging Executable__
 *	   Host        download      Dev board + MCU
 *		[.elf]  ------------------>  [Flash]
 *
 *	How to download executable to target
 *
 *	.You'll need OpenOCD on the host and a In-Circuit Programmer/Debugger (Debug adapter) connected via USB. The debug adapter connects to target via SWD or JTAG.
 *
 *	OpenOCD(Open On Chip Debugger)
 *	. The Open On-Chip Debugger (OpenOCD) aims to provide debugging, in-system programming, and boundary-scan testing for embedded target devices.
 *	. It is free and opensource host application allows you to program, debug, and analyze your applications using GDB.
 *	. It supports various target boards based on different processor architecture.
 *	. OpenOCD currently supports many types of debug adapters: USB based, parallel port-based, and other standalone boxes that run OpenOCD internally.
 *	. GDB Debug: it allows ARM7 (ARM7TDMI and ARM720T), ARM9 (ARM920T, ARM922T, ARM926EJ-S, ARM966E-S), XScale (PXA25x, IXP42x), Cortex-M3 (Stellaris LM3, ST STM32,
 *	  and Energy Micro EFM32) and Intel Quark (x10xx) based cores to be debugged via the GDB protocol.
 *	. Flash Programming: Flash writing is supported for external CFI-compatible NOR flashes (Intel and AMD/Spansion command set) and several internal flashes (LPC1700,
 *	  LPC1800, LPC2000, LPC4300, AT91SAM7, AT91SAM3U, STR7x, STR9x, LM3, STM32x, and EFM32). Preliminary support for various NAND flash controllers (LPC3180,
 *	  Orion, S3C24xx, more) is included.
 *
 *	  __Programming adapters__
 *	 . Programming adapters are used to get access to the debug interface of the target with native protocol signaling such as SWD or JTAG since
 *	   HOST doesn't support such interfaces.
 *	 . It does protocol conversion. For example, commands and messages coming from host application in the form of USB packets will be converted
 *	   to equivalent debug interface signaling (SWD or JTAG) and vice versa.
 *	 . Mainly debug adapter helps you to download and debug the code.
 *	 . Some advanced debug adapters will also help you to capture trace events such as on the fly instruction trace and profiling information.
 *
 *		Popular debug adapters:
 *	Segger J-LINK EDU - JTAG/SWD Debugger (used at Byton)
 *	Keil ULINK Pro
 *	ST-LINK/V2  (the ones embedded into nucleo and discovery boards only use SWD not JTAG)
 *
 *	__Path to CPU:__
 *	Host PC -> OpenOCD -> ST-LINK driver / USB -> SWD/JTAG adapter -> DP (SWJ-DP / SW-DP) via SWDCLK & SWDIO -> AHB-AP -> AHB interconnect -> Core
 *																																|--> AHB bus -> SRAM/Flash/other peripherals
 *	__Steps to download the code using OpenOCD__
 *	1. Download and install OpenOCD
 *	2. Install Telnet client (for windows you can use PuTTY software)
 *	   . If you cannot use Telnet application you can also use "GDB client"
 *	3. Run OpenOCD with the board configuration file
 *	4. Connect to the OpenOCD via Telnet Client or GDB client
 *	5. Issue commands over Telnet or GDB Client to OpenOCD to download and debug the code.
 *
 *	to start openOCD with the stm32f4 nucleo board:
 *
 *	make clean
 *	make load
 *
 *	Once OpenOCD server is running. Now you can connect to this server over various client programs such as telnet client, GDB clients, etc.
 *
 *	Now open a 2nd terminal for GDB after running "make load" to start the OpenOCD server.
 *
 *	arm-none-eabi-gdb.exe
 *	target remote localhost:3333
 *
 *	then,
 *	monitor reset init
 *
 *	then,
 *	monitor flash write_image erase final.elf
 *
 *	then,
 *	monitor reset halt
 *
 *	then,
 *	monitor resume
 *
 *	OpenOCD memory access commands (openocd.org/doc/html/General-Commands.html)
 *	mdd, mdw, mdh, mdb
 *
 *	monitor mdw 0x20000000 4
 *
 *	breakpoints:
 *	monitor bp 0x080001fe 2 hw   //set breakpoint at task1_handler
 *
 *		__'C' standard library newlib & new-lib-nano__
 *	Newlib:
 *	. Newlib is a 'C' standard library implementation intended for use on embedded systems, and it is introduced by Cygnus Solutions (now Red Hat)
 *	. "Newlib" is written as a Glibc (GNU libc) replacement for embedded systems. It can be used with no OS ("bare metal") or with a lightweight RTOS
 *	. Newlib ships with gnu ARM toolchain installation as the default C standard library
 *	. GNU libc (glibc) includes ISO C, POSIX, System V, and XPG interfaces. uClibc provides ISO C, POSIX and System V, while Newlib provides only ISO C.
 *
 *	Newlib-nano:
 *	. Due to the increased feature set in newlib, it has become too bloated to use on the systems where the amount of memory is very much limited.
 *	. To provide a C library with a minimal memory footprint, suited for use with micro-controllers, ARM introduced newlib-nano based on newlib.
 *
 *	Low level system calls:
 *	. The idea of Newlib is to implement the hardware-independent parts of the standard C library and rely on a few low-level system calls that must
 *	  be implemented with the target hardware in mind.
 *	. When you are using newlib, you must implement the system calls appropriately to support devices, file-systems, and memory management.
 *
 *							printf()    Embedded application
 *							   |
 *							   v
 *						  Newlib-Nano   'C' standard library
 *			  			   _write();
 *			  		  	       |
 *	_write function			   v
 *	implemented here ->	 _write(){...}    Stubs (low level target
 *	will receive all	   |    |    |		specific call implementation)
 *  the strings        	   v    v    v
 *  pre-formatted by     UART  ITM  LCD
 *  printf():
 *
 *
 *  Linking the c standard library adds a lot of extra text sections to the obj-dump final.elf file. You have to merge them separately.
 *
 *				Reset_handler()
 *					  |
 *			Initialize data section
 *			    	  |
 *			Initialize bss section
 *			    	  |
 *			Initialize 'C' std library    __libc_init_array();
 *			    	  |
 *			       main();
 *
 *
 *	gcc.gnu.org/onlinedocs/gcc/ARM-Options.html
 *
 *	To use std c library with semi-hosting support, change the --specs=nano.specs (Newlib-nano) in the Makefile to --specs=rdimon.specs
 *
 *	to enable semihosting feature in the PuTTY OpenOCD terminal,
 *	arm semihosting enable
 *
 *	<END OF COURSE!>
 */

#include <stdio.h>
#include <stdint.h>
#include "main.h"


int main(void)
{
	for(;;);
}
