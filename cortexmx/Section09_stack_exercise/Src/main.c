/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdio.h>
#include<stdint.h>

/*
 * Stack memory is part of the main memory (internal or external RAM) reserved for temporary storage of data (transient data).
 * Mainly used during function, interrupt/exception handling
 * Stack memory is accessed in LIFO (last in first out)
 * The stack can be accessed using PUSH and POP instructions or using any memory manipulation instructions (LD,STR)
 * The stack is traced using a stack pointer (SP) register. PUSH and POP instructions affect (decrement/increment) stack pointer register (SP,R13).
 *
 *     __Stack memory uses:__
 * 1. The temporary storage of processor register values
 * 2. The temporary storage of local variables of the function
 * 3. During system exception or interrupt, stack memory will be used to save the context (some general purpose registers,
 *  processor status register, return address) of the currently executing code.
 *
 *   SRAM (128KB) split into a few parts:
 *   Global Data:
 *   Part of RAM is utilized when the program contains global data and static local variables. You can even store instructions and execute from this "global" area
 *
 *   Heap:
 *   Another part of RAM is utilized during dynamic memory allocation (heap)
 *
 *   Stack:
 *   Utilized during function call to save temporary data, Temporary storage of local variables of the function, temporary storage of stack frames
 *   during interrupts and exceptions.
 *
 *   In ARM Cortex MX, stack model is (FD) full descending.
 *   PUSH decrements SP, POP increments SP
 *
 *   Stack Types (PUSH/POP):
 *   Full Ascending/Descending (full points to latest filled location)
 *   Empty Ascending/Descending (empty points to next empty location)
 *
 *   __Banked Stack Pointers__
 *   1. Cortex M Processor physically has 3 stack pointers: SP(R13), MSP and PSP
 *   MSP: Main stack pointer
 *   PSP: Processor stack pointer
 *
 *   SP is called as current stack pointer.
 *
 *   2. After processor reset, by default, MSP will be selected as current stack pointer. That means SP copies the contents of MSP.
 *
 *   3. Thread mode can change the current stack pointer to PSP by configuring the CONTROL register's SPSEL bit.
 *
 *   4. Handler mode code execution will always use MSP as the current stack pointer. That also means, changing the value of
 *   SPSEL bit being in the handler mode doesn't make any sense. The write will be ignored.
 *
 *	 5. MSP will be initialized automatically by the processor after reset by reading the content of the address 0x0000 0000
 *
 *	 6. If you want to use the PSP then make sure that you initialize the PSP to valid stack address in your code.
 *
 *   __For Thread mode:__
 *   If SPSEL = 0, current SP(R13) = MSP
 *   If SPSEL = 1, current SP(R13) = PSP
 */

#include <stdio.h>

#define SRAM_START 			0x20000000U
#define SRAM_SIZE 			(128 * 1024)
#define SRAM_END 			((SRAM_START) + (SRAM_SIZE))
#define STACK_START 		SRAM_END

#define STACK_MSP_START 	STACK_START
#define STACK_MSP_END 		(STACK_START + 512)
#define STACK_PSP_START		STACK_MSP_END

int func_add(int a, int b, int c, int d)
{
	return a+b+c+d;
}

__attribute__((naked)) void change_sp_to_psp(void)
{
	__asm volatile(".equ SRAM_END, (0x20000000 + ( 128 * 1024))");
	__asm volatile(".equ PSP_START, (SRAM_END-512)");
	__asm volatile("LDR R0, =PSP_START");
	__asm volatile("MSR PSP, R0");
	__asm volatile("MOV R0, #0X02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR");
}

void generate_exception(void)
{
	__asm volatile("SVC #0X2");
}

int main(void)
{

	change_sp_to_psp();
	int ret;

	ret = func_add(1,4,5,6);

	printf("result = %d\n",ret);

	generate_exception();

	for(;;);
}

void SVC_Handler(void)
{
	printf(" in SVC_Handler\n");
}

/*  		__MSP, PSP summary__
 *  1. Physically there are 2 stack pointer registers in Cortex-M Processors
 *  2. Main Stack Pointer (MSP): This is the default stack pointer used after reset, and is used for all exception/interrupt handlers
 *     and for codes which run in thread mode.
 *  3. Process Stack Pointer (PSP): This is an alternate stack pointer that can only be used in thread mode. It is usually used for application
 *     task in embedded systems and embedded OS.
 *  4. After power-up, the processor automatically initializes the MSP by reading the first location of the vector table.
 *
 *     __Changing SP__
 *  To access MSP and PSP in assembly code, you can use the MSR and MRS instructions.
 *  In a C program you can write a naked function ('C' like assembly function which doesn't have epilogue and prologue sequences) to change
 *  the currently selected stack pointer.
 *
 *
 *  	__Procedure Call Standard for the ARM Architecture (AAPCS)__
 *  . R0, R1, R2, R3, R12, R14(LR) registers are called the "caller saved registers", it's the responsibility of the caller to save these
 *    registers on stack before calling the function if those values will still be needed after the function call and retrieve it back once
 *    the called function returns. Register values that are not required after the function call don't have to be saved.
 *  . R4 to R11 are called "callee saved registers". The function or subroutine being called needs to make sure that, contents of these
 *    registers will be unaltered before exiting the function.
 *  . According to this standard, caller function uses R0,R1,R2,R3 registers to send input arguments to the callee function.
 *  . The callee function uses registers R0 and R1 to send the result back to the caller function.
 *
 *    https://static.docs.arm.com/ihi0042/g/aapcs32.pdf
 *
 *    directory path to check out::   /stack_exercise/Debug/stack.list
 *
 *    __Interrupt/Exception Handler case__
 *    The processor saves "caller saved registers" since there is no caller for interrupt or exception handler.
 *    So, you can write an interrupt/exception handler as normal 'c' function without worrying about AAPCS rules.
 *    Hardware saves "Stack Frame" -> [R0,R1,R2,R3,R12  LR,PC,XPSR] onto the Stack (with stacking and unstacking as exception is entered/exited)
 *
 *    __Stack Initialization__
 *    Before reaching main (done by processor reset which reads first location of vector table from startup code)
 *    After reaching main function, you may again reinitialize the stack pointer.
 *
 *    __Stack Initialization Tips__
 *    1) Evaluate your targeted application. Decide the amount of stack that would be needed for the worst-case scenario of your application runtime.
 *    2) Know your processor's stack consumption model (FD,FA,ED,EA)
 *    3) Decide stack placement in the RAM (middle, end, external memory)
 *    4) In many applications, there may be second stage stack init. For example, if you want to allocate stack in external SDRAM then first start with
 *       internal RAM, in the main or startup code initialize the SDRAM then change the stack pointer to point to SDRAM.
 *    5) If you are using the ARM Cortex MX processor, make sure that the first location of the vector table contains the initial stack address (MSP).
 *       The startup code of the project usually does this.
 *    6) You may also use the linker script to decide the stack, heap, and other RAM area boundaries. Startup code usually fetches boundary information
 *       from linker scripts.
 *    7) In an RTOS scenario, the kernel code may use MSP to trace its own stack and configure PSP for user task's stack.
 */
